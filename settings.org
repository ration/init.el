* Initialization file for emacs

Utilizes straight.el for most of the initalization stuff. Nativecomp branch is in use - this might have implications
on the general usability of this configuration.

* Load custom el and environment specific settings
#+BEGIN_SRC emacs-lisp

  (let ((local (expand-file-name "local.el" user-emacs-directory)))
  (message "Loading local settings %s" local)
  (if (file-exists-p local)
        (load-file local)
	(message "WARNING - no local.el")))




  ;; Set Custom file to another place
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)

#+END_SRC
* Create backups in separate directory and disable lock files
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)

(use-package no-littering
  :config (setq auto-save-file-name-transforms
                `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
  (require 'recentf)
(add-to-list 'recentf-exclude no-littering-var-directory)
(add-to-list 'recentf-exclude no-littering-etc-directory))
#+END_SRC
* UI Look and feel. Note some of this is in early-init.el
** For nostalgia my old theme
#+BEGIN_SRC emacs-lisp :tangle no
  (defun theme-slate-grey (&optional frame)
    "Set custom background color."
    (with-selected-frame (or frame (selected-frame))
      (set-background-color "DarkSlateGray")
      (set-face-background 'mode-line "Wheat")
      (set-face-foreground 'mode-line "DarkSlateGray")
      (set-face-background 'mode-line"LightSlateGray")
      (set-face-foreground 'mode-line "Wheat")
      (set-background-color "DarkSlateGray")
      (set-foreground-color  "Wheat")
      ))

#+END_SRC
** Theme
#+BEGIN_SRC emacs-lisp
(use-package idea-darkula-theme
  :config
  (load-theme 'idea-darkula))
#+END_SRC
Change title to show buffer path
#+begin_src emacs-lisp
(setq-default frame-title-format '("%f [%m] - emacs]"))
#+end_src
* File formatting stuff
#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
(setq-default fill-column 120)
#+END_SRC
** Editorconfig
#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :config
  (editorconfig-mode 1))
#+END_SRC
** Cleanup-buffer
#+BEGIN_SRC emacs-lisp
  (defun cleanup-buffer ()
  "Perform a bunch of safe operations on the whitespace content of a buffer.
  Does not indent buffer, because it is used for a before-save-hook, and that
  might be bad."
  (delete-trailing-whitespace))
#+END_SRC
* Enable narrowing (excl. goal-column)
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-defun  'disabled nil)
  (put 'narrow-to-page   'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (unbind-key (kbd "C-x C-n"))
#+END_SRC
* Make sure server is running
#+BEGIN_SRC emacs-lisp
(require 'server)
(unless (server-running-p) (server-start))
(defun my-raise-frame-and-give-focus ()
  server-raise-frame)
(add-hook 'server-switch-hook 'my-raise-frame-and-give-focus)
#+END_SRC
* Org protocol
#+begin_src emacs-lisp
(require 'org-protocol)
(defun my-org-protocol-store-link-advice (orig &rest args)
  (raise-frame)
  (apply orig args))

(advice-add 'org-protocol-capture :around
            #'my-org-protocol-store-link-advice)
#+end_src
* Google this
#+BEGIN_SRC emacs-lisp
(use-package google-this)
#+END_SRC
* Compile without save
#+BEGIN_SRC emacs-lisp
(setq compilation-ask-about-save nil)
#+END_SRC
* Buffer manipulation
** Smartparens
Feels like it gets is more in the way. The ctrl up down in context feels
like a nice idea but it might need something like a hydra to be really useful.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package smartparens
  :config
  (add-hook 'prog-mode-hook 'smartparens-mode)
  :init
  (bind-key "<C-down>" #'sp-forward-sexp smartparens-mode-map)
  (bind-key "<C-up>" #'sp-backward-sexp smartparens-mode-map)
  (global-unset-key "\C-o")
  (bind-key "\C-o" #'sp-select-next-thing smartparens-mode-map))
#+END_SRC
** Flash modeline
#+BEGIN_SRC emacs-lisp
(defun double-flash-mode-line ()
  "Flash the modeline"
  (let ((flash-sec (/ 1.0 20)))
    (invert-face 'mode-line)
    (run-with-timer flash-sec nil #'invert-face 'mode-line)
    (run-with-timer (* 2 flash-sec) nil #'invert-face 'mode-line)
    (run-with-timer (* 3 flash-sec) nil #'invert-face 'mode-line)))
#+END_SRC
** Rainbow delimeters (Not enabled anywhere by default)
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :config
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(rainbow-delimiters-depth-1-face ((t (:foreground "dark orange"))))
   '(rainbow-delimiters-depth-2-face ((t (:foreground "deep pink"))))
   '(rainbow-delimiters-depth-3-face ((t (:foreground "chartreuse"))))
   '(rainbow-delimiters-depth-4-face ((t (:foreground "deep sky blue"))))
   '(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
   '(rainbow-delimiters-depth-6-face ((t (:foreground "orchid"))))
   '(rainbow-delimiters-depth-7-face ((t (:foreground "spring green"))))
   '(rainbow-delimiters-depth-8-face ((t (:foreground "sienna1"))))))
;;  :hook (prog-mode . rainbow-delimeters-mode))

#+END_SRC
** Company
Invert the navigation direction if the the completion popup-isearch-match is displayed on top (happens near the bottom of windows).
Also make right or left arrow keys abort the completion.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :bind (:map company-active-map
              ( "<right>" . company-abort)
              ( "<left>" . company-abort))
  :config
  (setq company-show-numbers t)
  (setq company-tooltip-align-annotations t)
  (setq company-tooltip-flip-when-above t)
  (global-company-mode))

(use-package company-quickhelp
  :ensure t
  :init
  (company-quickhelp-mode 1)
  (use-package pos-tip
    :ensure t))
#+END_SRC

** (Ya)folding/sippet
#+BEGIN_SRC emacs-lisp
(use-package yafolding)
(use-package yasnippet
  :config
  (yas-global-mode 1)
  (require 'yasnippet)
  (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets"))
(use-package yasnippet-snippets)
#+END_SRC
** Diff-hl (find uncommitted changes)
#+BEGIN_SRC emacs-lisp :tangle no
(use-package diff-hl
  :config
    (add-hook 'prog-mode-hook 'smartparens-mode))
#+END_SRC
** Helpful
#+begin_src emacs-lisp
(use-package helpful)
(global-set-key (kbd "C-h f") #'helpful-callable)
(global-set-key (kbd "C-h v") #'helpful-variable)
(global-set-key (kbd "C-h k") #'helpful-key)
;; Lookup the current symbol at point. C-c C-d is a common keybinding
;; for this in lisp modes.
(global-set-key (kbd "C-c C-d") #'helpful-at-point)

;; Look up *F*unctions (excludes macros).
;;
;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
;; already links to the manual, if a function is referenced there.
(global-set-key (kbd "C-h F") #'helpful-function)

;; Look up *C*ommands.
;;
;; By default, C-h C is bound to describe `describe-coding-system'. I
;; don't find this very useful, but it's frequently useful to only
;; look at interactive functions.
(global-set-key (kbd "C-h C") #'helpful-command)
#+end_src
** Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config (which-key-mode))
#+END_SRC
** Allow minibuffer in minibuffer
#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers 1)
#+END_SRC
** Kill stuff without putting into kill-ring
#+BEGIN_SRC emacs-lisp
(defun kill-line-without-copy ()
  "Deletes from current position to end of line without putting into the kill-ring."
  (interactive)
  (delete-region (point) (line-end-position))
  )

(defun backward-kill-word-without-copy (arg)
  "Deletes from current backwards word without putting into the kill-ring."
  (interactive "p")
  (delete-region (point) (progn (forward-word (- arg)) (point))))
#+END_SRC
** Avy / ace
#+begin_src emacs-lisp
(use-package avy
  :bind ("C-å" . avy-goto-char-timer))

(use-package ace-jump-mode)
#+end_src
** Bufler
#+BEGIN_SRC emacs-lisp
(use-package bufler)
#+END_SRC
** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy)
#+END_SRC
** Copy filename to kill-ring
#+BEGIN_SRC emacs-lisp
(defun filename ()
    "Copy the full path of the current buffer."
    (interactive)
    (kill-new (buffer-file-name (window-buffer (minibuffer-selected-window)))))
#+END_SRC
** Quick chmod buffer and chmod u+x buffer
#+BEGIN_SRC emacs-lisp
  (defun chmod-buffer()
    (interactive)
    (let ((current-buffer (buffer-file-name)))
      (chmod current-buffer (read-file-modes "mode: " current-buffer))))
   (defun chmod-buffer-user-executable ()
   (interactive)
    (let* ((current-buffer (buffer-file-name))
           (modes (or (if current-buffer (file-modes current-buffer) 0)
                  (error "File not found. Not saved?"))))
      (chmod current-buffer (file-modes-symbolic-to-number "u+x" modes) )))

#+END_SRC
** file path to kill ring
#+begin_src emacs-lisp
(defun my-copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

#+end_src
** sudo-save
#+BEGIN_SRC emacs-lisp
(defun sudo-save ()
  "Save file with sudo"
  (interactive)
  (if (not buffer-file-name)
      (write-file (concat "/sudo:root@localhost:" (ido-read-file-name "File:")))
    (write-file (concat "/sudo:root@localhost:" buffer-file-name))))

#+END_SRC
** Multiple cursors
Some usage through chords (see chords)
#+begin_src emacs-lisp
(use-package multiple-cursors
  :config
  (setq mc/always-run-for-all t)
  :bind ("C-<" . mc/mark-next-like-this)
        ("C--" . mc/edit-lines))

#+end_src
** rename-file-and-buffer
#+begin_src emacs-lisp
(defun rename-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil))))))
#+end_src
** goto-last-change
#+begin_src emacs-lisp
(use-package goto-last-change
:bind ("C-§" . goto-last-change))
#+end_src
** smart-mode-line
#+begin_src emacs-lisp
(use-package smart-mode-line
  :config (setq sml/theme 'respectful))
#+end_src
* Organizing and finding files and buffers
** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :init
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-idle-delay 0.2)
  (setq company-dabbrev-downcase nil))
(use-package request)
#+END_SRC


** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (setq-default helm-locate-project-list local-projects)
  (projectile-mode t))
#+END_SRC
** Treemacs
#+BEGIN_SRC emacs-lisp :tangle no
(use-package treemacs
  :config (treemacs-follow-mode 1)
  (treemacs-filewatch-mode 1)
  (treemacs-fringe-indicator-mode 1))
   (use-package treemacs-projectile
     :after treemacs projectile)
(defun my-treemacs-back-and-forth ()
  (interactive)
  (if (treemacs-is-treemacs-window-selected?)
      (aw-flip-window)
    (treemacs-select-window)))
#+END_SRC
** Springboard
#+BEGIN_SRC emacs-lisp
(use-package springboard)
#+END_SRC
** recentf: Keep opened files history
#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 100)
(setq recentf-max-saved-items 100)
(defun save-recentf-silently()
  (let ((inhibit-message t))
    (recentf-save-list)))
(run-at-time nil (* 5 60) 'save-recentf-silently)
#+END_SRC
** goto-last-change
#+BEGIN_SRC emacs-lisp
(use-package goto-last-change)
#+END_SRC

** Fuzzy find files (fzf). Bind it to helm-ff
#+BEGIN_SRC emacs-lisp
(use-package fzf
  :init
  (global-set-key (kbd "C-c g") (lambda () (interactive)
			    (fzf/start "~"))))
(defun my-helm-run-fzf (candidate)
  (interactive)
  (let ((helm-current-dir (file-name-directory (helm-get-selection))))
      (fzf/start helm-current-dir)))

(defun my-helm-ff-switch-to-fzf ()
  "Stop helm find-files and use fzf"
  (interactive)
  (with-helm-alive-p
    (helm-exit-and-execute-action 'my-helm-run-fzf)))


#+END_SRC
* Org Mode

Unbind colliding mappings
#+begin_src emacs-lisp
(define-key org-mode-map (kbd "M-<down>") nil)
(define-key org-mode-map (kbd "M-<up>") nil)
(define-key org-mode-map (kbd "M-<left>") nil)
(define-key org-mode-map (kbd "M-<right>") nil)
(define-key org-mode-map (kbd "ESC <left>") 'org-metaleft)


;; (define-key org-agenda-mode-map (kbd "M-<down>") nil)
;; (define-key org-agenda-mode-map (kbd "M-<up>") nil)
;; (define-key org-agenda-mode-map (kbd "M-<left>") nil)
;; (define-key org-agenda-mode-map (kbd "M-<right>") nil)
;;
;; (define-key org-agenda-keymap (kbd "M-<down>") nil)
;; (define-key org-agenda-keymap (kbd "M-<up>") nil)
;; (define-key org-agenda-keymap (kbd "M-<left>") nil)
;; (define-key org-agenda-keymap (kbd "M-<right>") nil)


#+end_src
Journal, Rifle

Org-journal doesn't seem to work with straight.

#+BEGIN_SRC emacs-lisp :tangle no
(require 'find-lisp)
(setq calendar-week-start-day 1)
(use-package org-journal
  :init
  (setq org-journal-dir (concat dropbox-home "Org/Journal"))
  (setq org-journal-file-type "weekly")
  (setq org-journal-file-format "%Y-%m-%d.org")
  (setq org-journal-date-format "%y-%m-%d, %A"))
#+END_SRC

ox-gfm allows exporting Github Flavored markdown
#+BEGIN_SRC emacs-lisp
(use-package ox-gfm)
(setq org-agenda-directory (concat dropbox-home "/Org/"))
(setq org-agenda-files
      (find-lisp-find-files org-agenda-directory "\.org$"))
(setq-default org-catch-invisible-edits 'smart)
(setq org-default-notes-file (concat dropbox-home "/Documents/Orgzly/todo.org"))
(setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))

(add-hook 'auto-save-hook 'org-save-all-org-buffers)
(add-hook 'org-mode-hook 'flyspell-mode)

(add-hook 'org-agenda-mode-hook (lambda () (setq show-trailing-whitespace nil)))
(add-hook 'org-mode-hook
          (lambda () (add-hook 'before-save-hook 'cleanup-buffer nil 'local)))
(use-package org-super-agenda)
#+END_SRC
** Plantuml
#+BEGIN_SRC emacs-lisp
  (defun my-org-confirm-babel-evaluate (lang body)
    (not (string= lang "plantuml")))  ; don't ask for ditaa
  (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path
        (expand-file-name (concat dropbox-home "/home/elisp/java-libs/plantuml.jar")))

  (load (expand-file-name (concat dropbox-home "/home/elisp/ob-plantuml.el")))
#+END_SRC

** Org clock stuff
#+BEGIN_SRC emacs-lisp :tangle no
    (use-package org-clock-today)
    (use-package org-mru-clock)
  (defun x-org-clock-sum-today ()
    "Visit each file in `org-agenda-files' and return the total time of today's
  clocked tasks in minutes."
    (let ((files (org-agenda-files))
          (total 0))
      (org-agenda-prepare-buffers files)
      (dolist (file files)
        (with-current-buffer (find-buffer-visiting file)
          (setq total (+ total (org-clock-sum-today)))))
      total))
  (defun x-org-clock-get-clock-string-today ()
    "Form a clock-string, that will be shown in the mode line.
  If an effort estimate was defined for the current item, use
  01:30/01:50 format (clocked/estimated).
  If not, show simply the clocked time like 01:50. All Tasks"
    (let ((clocked-time (x-org-clock-sum-today)))
      (if org-clock-effort
          (let* ((effort-in-minutes (org-duration-to-minutes org-clock-effort))
                 (work-done-str
                  (propertize (org-duration-from-minutes clocked-time)
                              'face
                              (if (and org-clock-task-overrun
                                       (not org-clock-task-overrun-text))
                                  'org-mode-line-clock-overrun
                                'org-mode-line-clock)))
                 (effort-str (org-duration-from-minutes effort-in-minutes)))
            (format (propertize " [%s/%s] (%s)" 'face 'org-mode-line-clock)
                    work-done-str effort-str org-clock-heading))
        (format (propertize " [%s] (%s)" 'face 'org-mode-line-clock)
                (org-duration-from-minutes clocked-time)
                org-clock-heading))))
  (defun current-clock-time-to-file ()
     (interactive)
     (with-temp-file "~/.emacs.d/.task"
       (if (org-clocking-p)
         (insert (x-org-clock-get-clock-string-today))
         (insert ""))))
  (run-with-timer 1 60 'current-clock-time-to-file)
  (add-hook 'org-clock-in-hook 'current-clock-time-to-file)
  (add-hook 'org-clock-out-hook 'current-clock-time-to-file)


#+END_SRC
** org-clubhouse
#+BEGIN_SRC emacs-lisp
(use-package org-clubhouse
  :straight (:host github :repo "glittershark/org-clubhouse")
  :init (setq org-clubhouse-state-alist
      '(("TODO"   . "Backlog")
        ("ACTIVE" . "In Development")
        ("PENDING" . "Pending")
        ("REVIEW"   . "Ready for Review")
        ("DONE"   . "Completed")))
        (setq org-clubhouse-workflow-name "Development"))
#+END_SRC
** Emphasis
#+BEGIN_SRC emacs-lisp
(setq org-emphasis-alist '(
			  ("/"  (:foreground "red" :background: "yellow"))
			  ("\""  (:foreground "red" :background: "yellow"))
			  ("/" italic "<i>" "</i>")
			  ("_" underline "<span style=\"text-decoration:underline;\">" "</span>")
			  ("-" (:overline t) "<span style=\"text-decoration:overline;\">" "</span>")
			  ("=" org-code "<code>" "</code>" verbatim)
			  ("*" org-verbatim "<code>" "</code>" verbatim)
			  ("+" (:strike-through t) "<del>" "</del>")))
(setq org-hide-emphasis-markers nil)
#+END_SRC
** Org-analyzer
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-analyzer)
#+END_SRC

** Capture templates
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates (append
                             (quote
                              (("b" "Bloggging" entry
                                (file (lambda () concat dropbox-home "/Org/blog.org")))
                                "")
                               ("n" "Note" entry
                                (file (lambda () (concat dropbox-home "/Org/notes.org")))
                                "* %?")
                               ("t" "Generic TODO" entry
                                (file+headline "~/Org/todo.org" "Inbox")
                                "* TODO %?")
                               ("l" "Org Capture Text" entry (file+headline "~/Org/todo.org" "Protocol")
                               "* TODO %?\n%u\n#+begin_example\n%i\n#+end_example\n\nSource: %:link\n"
                               :empty-lines 1)
                               ("L" "Org Capture" entry (file+headline "~/Org/todo.org" "Protocol")
                               "* TODO %?\n%u\nSource: %:link\n"
                               :empty-lines 1)
                               )) (if (boundp 'project-specific-templates) project-specific-templates)))
#+END_SRC
** Reload images when running babel
#+BEGIN_SRC emacs-lisp
(defun shk-fix-inline-images ()
  (when org-inline-image-overlays)
    (org-redisplay-inline-images))

(with-eval-after-load 'org
  (add-hook 'org-babel-after-execute-hook 'shk-fix-inline-images))
#+END_SRC
** Bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
** org-gcal
If org-cal keys has been set install org-gcal and add a sync for it in agenda
#+begin_src emacs-lisp
(if (boundp 'org-gcal-client-id)
    (use-package org-gcal
      :config (define-key org-agenda-mode-map (kbd "ö") 'org-gcal-fetch)))
#+end_src
** Org-Roam (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-roam
:hook (after-init . org-roam-mode)
:custom (org-roam-directory  org-agenda-directory)
        (org-roam-db-location (concat org-agenda-directory "roam.db"))
      :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n g" . org-roam-show-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))))
(use-package org-roam-server
  :custom org-roam-server-port 9090)
#+END_SRC
** todoist
#+begin_src emacs-lisp
(if (boundp 'todoist-token)
    (use-package todoist
      :init (setq todoist-backing-buffer (concat org-agenda-directory "todoist.org"))))
#+end_src
* Hydra
#+begin_src emacs-lisp
(use-package hydra)
#+end_src
* Window management
Some window management and switching window is in global bindings. Maybe move here?
** Switch-window
Only need the resizing functions now
#+begin_src emacs-lisp
(use-package switch-window
  :bind ("C-s-<left>" . switch-window-mvborder-left)
  ("C-s-<right>" . switch-window-mvborder-right)
  ("C-s-<up>" . switch-window-mvborder-up)
  ("C-s-<down>" . switch-window-mvborder-down))
#+end_src
** Flashing active window when window is changed
#+begin_src emacs-lisp :tangle no
(make-face 'flash-active-buffer-face)
(set-face-attribute 'flash-active-buffer-face nil
                    :background "#FFFFFF" :foreground nil)
(defun highlight-selected-window ()
  "Highlight selected window with a different background color."
  (walk-windows (lambda (w)
                  (unless (eq w (selected-window))
                    (with-current-buffer (window-buffer w)
                      (buffer-face-set 'default)))))
  (buffer-face-set '(:background "#202020")))
(defun flash-active-buffer ()
  (interactive)
  (run-at-time "100 millisec" nil
               (lambda (remap-cookie)
                 (face-remap-remove-relative remap-cookie))
               (face-remap-add-relative 'default 'flash-active-buffer-face)))
(add-hook 'buffer-list-update-hook 'flash-active-buffer)
#+end_src
** Ace-windows
#+begin_src emacs-lisp
(use-package ace-window
:bind (("C-x §" . ace-window)))
#+end_src
** Shackle
#+BEGIN_SRC emacs-lisp
(use-package shackle
  :init
  (require 'shackle)
  (setq helm-display-function 'pop-to-buffer) ; make helm play nice
  (setq helm-swoop-split-window-function 'display-buffer)
  (add-to-list 'shackle-rules
               '("\\`\\*helm.*?\\*\\'" :regexp t :align t :size 0.9))
  (add-to-list 'shackle-rules
               '("\\`\\*Helm.*?\\*\\'" :regexp t :align right :size 0.4))
  (add-to-list 'shackle-rules
               '("\\`\\*Helpful.*?\\*\\'" :regexp t :align right :size 0.4))

  (add-to-list 'shackle-rules
               '("\\`\\*PLANTUML.*?\\*\\'" :popup t :regexp t :align below :size 0.4))

  :config
  (shackle-mode t))
#+END_SRC
** Purpose
TODO setup purpose
#+begin_src emacs-lisp :tangle no
(use-package window-purpose
  :init
  (require 'window-purpose)
;;  (add-to-list)
  (purpose-mode t))
#+end_src
* File editing modes
  *
#+BEGIN_SRC emacs-lisp

(if (version<= emacs-version "26")
    (use-package cl))

  (use-package pcre2el)

  (use-package xml+)
  (use-package restclient)
  (use-package powershell)
  (use-package plantuml-mode
    :init
    (setq plantuml-jar-path (concat dropbox-home "/home/elisp/java-libs/plantuml.jar"))
    (setq plantuml-default-exec-mode 'jar))

  (use-package dockerfile-mode)
  (use-package graphql)
  (use-package graphql-mode)

  (use-package yaml-mode
    :bind ("C-<tab>" . outline-cycle)
    :hook (yaml-mode . outline-minor-mode)
          (yaml-mode . (lambda ()  (progn (setq outline-regexp "^ *##")))))


  (use-package live-py-mode
    :config
    (setq live-py-version "python3"))
  (use-package highlight-indent-guides
    :config
    (setq highlight-indent-guides-method 'character)
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
#+END_SRC
** json

If you regularly use JSON string payloads embedded in another payload, you can use this to extract the contents as prettified json.

#+begin_src emacs-lisp
(defun my-json-pretty-print-from-string-to-kill-ring (start end)
  "Copy contents of a embedded json object and copy the content pretty printed into kill ring"
  (interactive "r")
  (if (use-region-p)
      (let ((regionp (buffer-substring start end)))
        (with-temp-buffer
          (insert (json-read-from-string regionp))
          (json-pretty-print-buffer)
          (clipboard-kill-region (point-min) (point-max))))))
(use-package json-mode)
#+end_src
** Markdown
#+BEGIN_SRC emacs-lisp
(add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC
** DONE Type/Javascript
#+BEGIN_SRC emacs-lisp

(defun my-lsp-mode-before-save-hook ()
  (when (and lsp-mode (eq major-mode 'typescript-mode))
    (lsp-eslint-apply-all-fixes)))

(use-package js2-mode
  :mode "\\.js\\'"
  :init
  (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
  (add-hook 'js2-mode-hook #'flymake-eslint-enable)
  (add-hook 'before-save-hook #'my-lsp-mode-before-save-hook)

  (setq js2-strict-missing-semi-warning nil)
  (setf js2-mode-indent-inhibit-undo t)
  (setq-default indent-tabs-mode nil)

  :config
  (setq lsp-eslint-server-command
        '("node"
          "/home/lahtela/Software/eslint/extension/server/out/eslintServer.js"
          "--stdio"))
  (setq lsp-eslint-node-path "/home/lahtela/Software/node/")
  (setq lsp-eslint-auto-fix-on-save t)
  (setq lsp-eslint-validate '("javascript" "javascriptreact" "typescript"))
  (setq lsp-eslint-trace-server nil)


  (with-eval-after-load "lsp-javascript-typescript"
    (add-hook 'js2-mode-hook #'lsp))
  (setq js2-basic-offset 2))

(use-package web-mode
  :ensure t
  :mode (("\\.html?\\'" . web-mode)
         ("\\.tsx\\'" . web-mode)
         ("\\.jsx\\'" . web-mode))
  :config
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-block-padding 2
        web-mode-comment-style 2

        web-mode-enable-css-colorization t
        web-mode-enable-auto-pairing t
        web-mode-enable-comment-keywords t
        web-mode-enable-current-element-highlight t
        web-mode-enable-auto-indentation nil))

(defun ts-goto-test-or-source ()
  "Switch between test and implementation"
  (interactive)
  (let* ((file (buffer-file-name))
         (test (string-match "\\(.*?\\)\\(\.test\\)?\\(\.tsx?\\)$" file)))

    (if (match-string 2 file)
        (let ((source (replace-regexp-in-string "\.test" "" file)))
          (if (file-exists-p source) (find-file source)))
      (let ((test (concat (match-string 1 file) ".test" (match-string 3 file))))
        (if (file-exists-p test) (find-file test))))))



(use-package typescript-mode
  :ensure t
  :bind (("M-<return>" . ts-goto-test-or-source))
  :config
  (setq typescript-indent-level 2)
  (add-hook 'typescript-mode #'subword-mode))

;(use-package tide
;  :init
;  :ensure t
;  :after (typescript-mode company flycheck)
;  :hook ((typescript-mode . tide-setup)
;         (typescript-mode . tide-hl-identifier-mode)))

(use-package css-mode
  :config
  (setq css-indent-offset 2))

(use-package jest
  :init (setq jest-executable "~/Software/nodejs/bin/npm test --"))
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck)
;  :hook (yaml-mode . flycheck-mode))


#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :config
  (define-key elpy-mode-map (kbd "M-<down>") nil)
  (define-key elpy-mode-map (kbd "M-<up>") nil)
  (define-key elpy-mode-map (kbd "M-<left>") nil)
  (define-key elpy-mode-map (kbd "M-<right>") nil)
  (setq elpy-rpc-pythonpath "/home/lahtela/.emacs.d/straight/repos/elpy")
:init (elpy-enable))
#+END_SRC
** logview
#+begin_src emacs-lisp
(use-package logview
    :mode (("\\.log?\\'" . logview-mode))
:hook ((logview-mode . read-only-mode)
       (logview-mode . auto-revert-mode)
       (logview-mode . (lambda () (setq show-trailing-whitespace nil)))))
#+end_src
** LSP

LSP is set up, but does not trigger automatically from builds

#+BEGIN_SRC emacs-lisp

;;(use-package lsp)
;;  :ensure lsp-mode
;;  :config
;;  (require 'lsp-clients)

;;  (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
;;  :init
;;  (setf lsp-eldoc-render-all nil)
;;  (setq lsp-inhibit-message t)
;;  (setq lsp-message-project-root-warning t))

(use-package lsp-mode
  :config (setq lsp-clients-typescript-log-verbosity "debug")
  (setq lsp-log-io 1))

(use-package lsp-ui :commands lsp-ui-mode)
(use-package helm-lsp :commands helm-lsp-workspace-symbol)
;(use-package lsp-treemacs
;  :config (lsp-treemacs-sync-mode 1)
;  :commands lsp-treemacs-errors-list)

(use-package lsp-java)

(use-package ccls
  :hook ((c-mode c++-mode objc-mode cuda-mode) .
         (lambda () (require 'ccls) (lsp))))

(use-package company-lsp
  :config
  (push 'company-lsp company-backends)
  (add-hook 'js2-mode-hook #'lsp))


#+END_SRC
** DAP
#+begin_src emacs-lisp :tangle no
(use-package dap-mode)
#+end_src
** Kotlin
#+begin_src emacs-lisp :tangle no
(use-package kotlin-mode)
#+end_src
** CSharp
#+begin_src emacs-lisp :tangle no
(use-package csharp-mode)
#+end_src
** Clojure
#+begin_src emacs-lisp
(use-package clojure-mode)
(use-package cider)
#+end_src
* Compilation modifications
Change compilation directory
#+begin_src emacs-lisp
(defun compile-in-dir (dir command)
  (interactive "DCompile in directory: \nsCommand: ")
  (let ((default-directory dir))
    (compile command)))
#+end_src
* Programming helpers
* Elfeed (RSS reader)
#+begin_src emacs-lisp
(use-package elfeed)
#+end_src
* UUID
#+begin_src emacs-lisp
(use-package uuid)
#+end_src

* Helm, Swoop and related
#+BEGIN_SRC emacs-lisp
(defun helm-execute-if-single-persistent-action (&optional attr split-onewindow)
  "Execute persistent action if the candidate list is less than 2 OR if theres no input and only one non trivial thing to select from"
  (interactive)
  (with-helm-alive-p
    (cond ((and (string= helm-input helm-ff-default-directory) (eq (helm-get-candidate-number) 3))
           (progn
             (helm-next-line)
             (helm-next-line)
             (helm-execute-persistent-action))
           )
          ((> (helm-get-candidate-number) 2) (double-flash-mode-line))
          (t (helm-execute-persistent-action))
          )))

(use-package helm
  :config
  (require 'helm-files)
  (setq helm-ff-allow-non-existing-file-at-point t)
  (unless (boundp 'helm-source-find-files)
    (setq helm-source-find-files (helm-make-source
                                     "Find Files" 'helm-source-ffiles)))
  (add-hook
   'helm-find-files-after-init-hook
   (lambda () (helm-add-action-to-source "C-, Switch to fzf" #'my-helm-run-fzf helm-source-find-files)))
  :bind (("M-x" . helm-M-x)
         ("C-x b" . helm-buffers-list)
         ("C-c f" . helm-recentf)
         ("M-y" . helm-show-kill-ring)

         ("C-x C-f" . helm-find-files)
         :map helm-find-files-map
         ("C-," . my-helm-ff-switch-to-fzf)
         ("<C-backspace>" . helm-find-files-up-one-level)
         :map helm-read-file-map
         ("<C-backspace>" . helm-find-files-up-one-level)

         :map helm-map
         ([tab] . helm-execute-if-single-persistent-action)
         ("C-i" . helm-select-action)))

(use-package helm-ag
  :init (custom-set-variables
         '(helm-follow-mode-persistent t)))
(defun my-helm-swoop-pre-input-function () "")
(use-package helm-swoop
  :bind (("C-s" . helm-swoop))
  :config
  (setq helm-swoop-speed-or-color nil)
  (setq helm-swoop-pre-input-function 'my-helm-swoop-pre-input-function)
  (bind-keys :map helm-swoop-map
             ("C-s" . kill-whole-line)))
(use-package helm-org-rifle)
(helm-mode 1)
(global-set-key (kbd "M-s M-s") 'isearch-forward)
(use-package helm-projectile)
#+END_SRC
* (Ma) Git
#+BEGIN_SRC emacs-lisp
(use-package magit)
(use-package forge)
#+END_SRC
** ediff
#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(custom-set-variables
 '(ediff-window-setup-function 'ediff-setup-windows-plain)
 '(ediff-diff-options "-w")
 '(ediff-split-window-function 'split-window-horizontally))
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)

#+end_src
* Blogging
#+BEGIN_SRC emacs-lisp
(use-package easy-jekyll
  :config
  (setq easy-jekyll-basedir (concat dropbox-home "git/blog/"))
  (setq easy-jekyll-url "https://lahtela.me")
  (setq markdown-command "pandoc -f markdown -t html -s --mathjax --highlight-style=pygments"))
#+END_SRC
* Save bookmarks always
If you set the variable bookmark-save-flag to 1, each command that sets a bookmark will also save your bookmarks; this
way, you don’t lose any bookmark values even if Emacs crashes. The value, if a number, says how many bookmark
modifications should go by between saving. If you set this variable to nil, Emacs only saves bookmarks if you explicitly
use M-x bookmark-save.
#+begin_src emacs-list
(setq bookmark-save-flag 1)
(require 'bookmark)
(bookmark-bmenu-list)

#+end_src
* Dashboard

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :demand t
  :init
 ;; Some org versions had this bug
  (setq org-priority-highest org-highest-priority)
  (setq org-priority-lowest org-lowest-priority)
  (dashboard-setup-startup-hook))

#+END_SRC
* Terminal (vterm)
- Synchronize default-directory with the added vterm-eval-cmds
- When scrolling up the buffer with ctrl-up, enable vterm-copy-mode
- Add a binding to find-trace-paths to ctrl-. into path texts in traces

#+begin_src emacs-lisp
(use-package find-trace-paths
  :straight (:host github :repo "ration/find-trace-paths"))

(defun my-vterm-backward-paragraph (&optional arg)
    (interactive)
  (unless vterm-copy-mode (vterm-copy-mode t))
  (backward-paragraph arg))

(defun vterm-update-pwd (path)
  (setq default-directory path))
  (add-to-list 'shackle-rules
               '("\\`\\*helm.*?\\*\\'" :regexp t :align t :size 0.9))

(if module-file-suffix
      (use-package vterm
        :bind (:map vterm-mode-map
                    (( "C-." . find-trace-paths)
                     ( "C-<up>" . my-vterm-backward-paragraph)))
        :config
        (setq vterm-max-scrollback 10000)
        (require 'vterm)
        (add-to-list 'vterm-eval-cmds '("update-pwd" (lambda (path) (setq default-directory path))))
        :hook ((vterm-mode . (lambda () (setq show-trailing-whitespace nil))))))
#+end_src
* Windows OS
#+BEGIN_SRC emacs-lisp
  ;; Load the ssh agent into environment variables if we have the pid file
  (defun load-agent-socket-env()
    (interactive)
    (defvar pid_file (concat (getenv "TEMP") "\\" "ssh_agent.pid"))
    (if (file-exists-p pid_file)
        (progn
        (setenv "SSH_AUTH_SOCK" (save-excursion
                                  (with-temp-buffer
                                    (insert-file-contents pid_file)
                                    (goto-char 1)
                                    (re-search-forward "SSH_AUTH_SOCK=\\(.*?\\);")
                                    (match-string 1)
                                    )))
      (setenv "SSH_AGENT_PID" (save-excursion
                                (with-temp-buffer
                                  (insert-file-contents pid_file)
                                  (goto-char 1)
                                  (re-search-forward "SSH_AGENT_PID=\\(.*?\\);")
                                  (match-string 1)
                                  ))))))





  (if (string-equal system-type "windows-nt")
      (progn
        (use-package ssh-agency)
        (setq find-program (concat git-home "/usr/bin/find.exe"))
        (setq grep-program (concat git-home "/bin/grep.exe"))
        (setq ispell-program-name "C:/Tatu/Apps/hunspell/bin/hunspell.exe")
        (setq helm-ag-base-command "c:/tatu/bin/ag --vimgrep")
  ))

#+END_SRC
* Global Bindings
Various global bindings
#+BEGIN_SRC emacs-lisp

(defun kill-and-save ()
  (interactive)
  (progn (save-buffer (current-buffer)) (kill-current-buffer)))

(global-set-key (kbd "ESC s-<f1>")  'kill-current-buffer)
(global-set-key (kbd "ESC <f1>")  'kill-and-save)
(global-set-key [f1]  'goto-line)
(global-set-key [f2]  'helm-projects-find-files)
(global-set-key [f3]  'helm-recentf)
(global-set-key [f4]  'helm-ag)

(global-set-key [f5]  'compile)
(global-set-key [f6]  'next-error)
(global-set-key [f8]  'magit-status)

(global-set-key [f9]  'org-agenda-list)
(global-set-key [f10]  'helm-org-rifle)
(global-set-key [f11]  (lambda () (interactive) (switch-to-buffer "*dashboard*")))
(global-set-key [f12]  'org-capture)

(global-set-key (kbd "M-k") 'kill-line-without-copy)

(global-set-key (kbd "C-§") 'whitespace-mode)
(global-set-key (kbd "s-§") (lambda () (interactive) (switch-to-buffer current-notes-file)))
(global-set-key (kbd "M-<up>") 'windmove-up)
(global-set-key (kbd "M-<down>") 'windmove-down)
(global-set-key (kbd "M-<left>") 'windmove-left)
(global-set-key (kbd "M-<right>") 'windmove-right)

(global-set-key (kbd "M-<backspace>") 'backward-kill-word-without-copy)
(global-set-key (kbd "M-z") 'zap-up-to-char)
(global-set-key (kbd "<M-S-up>") 'scroll-down-line)
(global-set-key (kbd "<M-S-down>") 'scroll-up-line)

(global-set-key (kbd "M-C-(") (lambda () (interactive) (scroll-down 10)))
(global-set-key (kbd "M-C-)") (lambda () (interactive) (scroll-up 10)))
(global-set-key (kbd "C-c o") 'helm-find-files)
(global-set-key (kbd "C-z") 'undo)
(global-set-key (kbd "C-ö") (lambda () (interactive) (point-to-register ?m)))
(global-set-key (kbd "C-ä") (lambda () (interactive) (jump-to-register ?m)))

#+END_SRC
** Key chords
#+begin_src emacs-lisp
(use-package key-chord
  :config
  (key-chord-define-global ",," 'avy-goto-char-timer)
  (key-chord-define-global "gg" 'helm-projectile)
  (key-chord-define-global "xx" 'helm-M-x)
  (key-chord-define-global "vv" 'goto-line)
  (key-chord-define-global "bb" 'purpose-switch-buffer-overload)
  (key-chord-mode 1))
#+end_src
* Databases
* AWS SAW

Read AWS logs from emacs.

#+begin_src emacs-lisp
(use-package aws-saw
  :straight (:host github :repo "ration/aws-saw.el"))
#+end_src

* Task organizer
My own task organizer stuff
#+begin_src emacs-lisp
(use-package chore
  :straight (:host github :repo "ration/chore.el")
  :config (key-chord-define-global "§§" 'chore-switch-to-note))
#+end_src
* Spell checking wcheck-mode
#+begin_src emacs-lisp
(use-package wcheck-mode
  :commands (wcheck-mode)
  :init
  (custom-set-faces
    '(wcheck-default-face ((t (:underline (:color: "red" :style wave)))))
    )

  (setq wcheck-language-data
    '
    (
      ("American English"
        (program . "/usr/bin/enchant-2")
        (args "-l" "-d" "en_US")
        (action-program . "/usr/bin/enchant-2")
        (action-args "-a" "-d" "en_US")
        (action-parser . enchant-suggestions-menu)
        (read-or-skip-faces
          ;; Only check comments & strings.
          ((emacs-lisp-mode c-mode)
            read font-lock-comment-face
            read font-lock-string-face
            )
          (nil))
        )
      ("Finnish"
        (program . "/usr/bin/enchant-2")
        (args "-l" "-d" "fi_FI")
        (action-program . "/usr/bin/enchant-2")
        (action-args "-a" "-d" "fi_FI")
        (action-parser . enchant-suggestions-menu)
      )
      ("Finglish"
        (program . "/home/lahtela/bin/finglish")
        (args "-l" )
        (action-program . "/home/lahtela/bin/finglish")
        (action-args "-a")
        (action-parser . enchant-suggestions-menu)
      )
    ))
  (setq wcheck-language "Finglish")
  )
#+end_src
* Exit Hook
Just save everything if we get TERM


#+begin_src emacs-lisp
(setq confirm-kill-processes nil)
(defun save-all () (interactive) (save-some-buffers t))
(add-hook 'kill-emacs-hook 'save-all)
#+end_src
