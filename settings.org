#+STARTUP: overview
* Initialization file for emacs

Utilizes straight.el for most of the initalization stuff.

* Load custom el and environment specific settings

  Override some settings from a local only configuration file

#+BEGIN_SRC emacs-lisp
(setq my-sync-gcal t)
(setq my-work-email-address "lahtela@iki.fi")
(setq my-work-email-signature (concat
		       "Tatu Lahtela\n"
		       "lahtela@iki.fi"))
(setq my-mu-work-dir "Work")

(let ((local (expand-file-name "local.el" user-emacs-directory)))
  (message "Loading local settings %s" local)
  (if (file-exists-p local)
      (load-file local)
    (message "WARNING - no local.el")))

;; Set Custom file to another place
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file 'noerror)

#+END_SRC

* Don't pop up the Warnings buffer on uninteresting stuff
#+begin_src emacs-lisp
(setq warning-minimum-level :error)
#+end_src
* Create backups in separate directory and disable lock files
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)

(use-package no-littering
  :config (setq auto-save-file-name-transforms
                `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
  (require 'recentf)
(add-to-list 'recentf-exclude no-littering-var-directory)
(add-to-list 'recentf-exclude no-littering-etc-directory))
#+END_SRC
* UI Look and feel. Note some of this is in early-init.el
** For nostalgia my old theme
#+BEGIN_SRC emacs-lisp :tangle no
(defun theme-slate-grey (&optional frame)
  "Set custom background color."
  (with-selected-frame (or frame (selected-frame))
    (set-background-color "DarkSlateGray")
    (set-face-background 'mode-line "Wheat")
    (set-face-foreground 'mode-line "DarkSlateGray")
     (set-face-background 'mode-line"LightSlateGray")
    (set-face-foreground 'mode-line "Wheat")
    (set-background-color "DarkSlateGray")
    (set-foreground-color  "Wheat")
    ))

#+END_SRC
** Theme
#+BEGIN_SRC emacs-lisp
(use-package atom-dark-theme
  :config (load-theme 'atom-dark))
;;(use-package idea-darkula-theme
;;  :config
;;  (load-theme 'idea-darkula))
#+END_SRC

Change title to show buffer path
#+begin_src emacs-lisp
(setq-default frame-title-format '("%f [%m] - emacs]"))
#+end_src
* File formatting stuff

Globally enable show trailing whitespace and increase fill-column (wrapping)

#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
(setq-default fill-column 120)
#+END_SRC

** EditorConfig

[[https://editorconfig.org/][EditorConfig]] settings.

#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :config
  (editorconfig-mode 1))
#+END_SRC
** Cleanup-buffer
#+BEGIN_SRC emacs-lisp
  (defun cleanup-buffer ()
  "Perform a bunch of safe operations on the whitespace content of a buffer.
  Does not indent buffer, because it is used for a before-save-hook, and that
  might be bad."
  (delete-trailing-whitespace))
#+END_SRC
* Enable narrowing (excl. goal-column)
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-defun  'disabled nil)
  (put 'narrow-to-page   'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (unbind-key (kbd "C-x C-n"))
#+END_SRC
* Make sure server is running
#+BEGIN_SRC emacs-lisp
(require 'server)
(unless (server-running-p) (server-start))
(defun my-raise-frame-and-give-focus ()
  server-raise-frame)
(add-hook 'server-switch-hook 'my-raise-frame-and-give-focus)
#+END_SRC
* Org protocol
#+begin_src emacs-lisp
(require 'org-protocol)
(defun my-org-protocol-store-link-advice (orig &rest args)
  (raise-frame)
  (apply orig args))

(advice-add 'org-protocol-capture :around
            #'my-org-protocol-store-link-advice)
#+end_src
* Google this
#+BEGIN_SRC emacs-lisp
(use-package google-this)
#+END_SRC
* Compile without save
#+BEGIN_SRC emacs-lisp
(setq compilation-ask-about-save nil)
#+END_SRC
* Buffer manipulation
** Surrounding stuff
*** Wrap region
    More simple than smartparens and does what I usually want. Just mark the region manually and wrap.
   #+begin_src emacs-lisp
   (use-package wrap-region
     :init
     (add-hook 'org-mode-hook 'wrap-region-mode)
     :config
     (wrap-region-add-wrapper "/" "/")
     (wrap-region-add-wrapper "=" "="))
   #+end_src
*** Smartparens
 Feels like it gets is more in the way. The ctrl up down in context feels
 like a nice idea but it might need something like a hydra to be really useful.
 #+BEGIN_SRC emacs-lisp :tangle no
 (use-package smartparens
   :config
   (add-hook 'prog-mode-hook 'smartparens-mode)
   :init
   (bind-key "<C-down>" #'sp-forward-sexp smartparens-mode-map)
   (bind-key "<C-up>" #'sp-backward-sexp smartparens-mode-map)
   (global-unset-key "\C-o")
   (bind-key "\C-o" #'sp-select-next-thing smartparens-mode-map))
 #+END_SRC
** Flash modeline
#+BEGIN_SRC emacs-lisp
(defun double-flash-mode-line ()
  "Flash the modeline"
  (let ((flash-sec (/ 1.0 20)))
    (invert-face 'mode-line)
    (run-with-timer flash-sec nil #'invert-face 'mode-line)
    (run-with-timer (* 2 flash-sec) nil #'invert-face 'mode-line)
    (run-with-timer (* 3 flash-sec) nil #'invert-face 'mode-line)))
#+END_SRC
** Rainbow delimeters (Not enabled anywhere by default)
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :config
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(rainbow-delimiters-depth-1-face ((t (:foreground "dark orange"))))
   '(rainbow-delimiters-depth-2-face ((t (:foreground "deep pink"))))
   '(rainbow-delimiters-depth-3-face ((t (:foreground "chartreuse"))))
   '(rainbow-delimiters-depth-4-face ((t (:foreground "deep sky blue"))))
   '(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
   '(rainbow-delimiters-depth-6-face ((t (:foreground "orchid"))))
   '(rainbow-delimiters-depth-7-face ((t (:foreground "spring green"))))
   '(rainbow-delimiters-depth-8-face ((t (:foreground "sienna1"))))))
;;  :hook (prog-mode . rainbow-delimeters-mode))

#+END_SRC
** Company
Invert the navigation direction if the the completion popup-isearch-match is displayed on top (happens near the bottom of windows).
Also make right or left arrow keys abort the completion.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :bind (:map company-active-map
              ( "<right>" . company-abort)
              ( "<left>" . company-abort))
  :config
  (setq company-show-numbers t)
  (setq company-tooltip-align-annotations t)
  (setq company-tooltip-flip-when-above t)
  (global-company-mode))

(use-package company-quickhelp
  :ensure t
  :init
  (company-quickhelp-mode 1)
  (use-package pos-tip
    :ensure t))
#+END_SRC

** (Ya)folding/sippet
#+BEGIN_SRC emacs-lisp
(use-package yafolding)
(use-package yasnippet
  :config
  (yas-global-mode 1)
  (require 'yasnippet)
  (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets"))
(use-package yasnippet-snippets)
#+END_SRC
** Diff-hl (find uncommitted changes)
#+BEGIN_SRC emacs-lisp :tangle no
(use-package diff-hl
  :config
    (add-hook 'prog-mode-hook 'smartparens-mode))
#+END_SRC
** Helpful
#+begin_src emacs-lisp
(use-package helpful)
(global-set-key (kbd "C-h f") #'helpful-callable)
(global-set-key (kbd "C-h v") #'helpful-variable)
(global-set-key (kbd "C-h k") #'helpful-key)
;; Lookup the current symbol at point. C-c C-d is a common keybinding
;; for this in lisp modes.
(global-set-key (kbd "C-c C-d") #'helpful-at-point)

;; Look up *F*unctions (excludes macros).
;;
;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
;; already links to the manual, if a function is referenced there.
(global-set-key (kbd "C-h F") #'helpful-function)

;; Look up *C*ommands.
;;
;; By default, C-h C is bound to describe `describe-coding-system'. I
;; don't find this very useful, but it's frequently useful to only
;; look at interactive functions.
(global-set-key (kbd "C-h C") #'helpful-command)
#+end_src
** Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config (which-key-mode))
#+END_SRC
** Allow minibuffer in minibuffer
#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers 1)
#+END_SRC
** Kill stuff without putting into kill-ring
#+BEGIN_SRC emacs-lisp
(defun kill-line-without-copy ()
  "Deletes from current position to end of line without putting into the kill-ring."
  (interactive)
  (delete-region (point) (line-end-position))
  )

(defun backward-kill-word-without-copy (arg)
  "Deletes from current backwards word without putting into the kill-ring."
  (interactive "p")
  (delete-region (point) (progn (forward-word (- arg)) (point))))
#+END_SRC
** Copy path to buffer
   #+begin_src emacs-lisp
   (defun my-dired-copy-dirname-as-kill ()
     "Copy the current directory into the kill ring."
     (interactive)
     (kill-new default-directory))
   #+end_src
** Avy / ace
#+begin_src emacs-lisp
(use-package avy
  :bind ("C-Ã¥" . avy-goto-char-timer))

(use-package ace-jump-mode)
#+end_src
** Bufler
#+BEGIN_SRC emacs-lisp
(use-package bufler)
#+END_SRC
** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy)
#+END_SRC
** Copy filename to kill-ring
#+BEGIN_SRC emacs-lisp
(defun filename ()
    "Copy the full path of the current buffer."
    (interactive)
    (kill-new (buffer-file-name (window-buffer (minibuffer-selected-window)))))
#+END_SRC
** Quick chmod buffer and chmod u+x buffer
#+BEGIN_SRC emacs-lisp
  (defun chmod-buffer()
    (interactive)
    (let ((current-buffer (buffer-file-name)))
      (chmod current-buffer (read-file-modes "mode: " current-buffer))))
   (defun chmod-buffer-user-executable ()
   (interactive)
    (let* ((current-buffer (buffer-file-name))
           (modes (or (if current-buffer (file-modes current-buffer) 0)
                  (error "File not found. Not saved?"))))
      (chmod current-buffer (file-modes-symbolic-to-number "u+x" modes) )))

#+END_SRC
** file path to kill ring
#+begin_src emacs-lisp
(defun my-copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

#+end_src
** Dired related stuff

   #+begin_src emacs-lisp
(use-package dired-narrow
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))
   #+end_src

   #+begin_src emacs-lisp
(use-package vscode-icon
  :commands (vscode-icon-for-file))
   (use-package dired-sidebar
     :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
     :ensure t
     :commands (dired-sidebar-toggle-sidebar)
     :init
     (add-hook 'dired-sidebar-mode-hook
               (lambda ()
                 (unless (file-remote-p default-directory)
                   (auto-revert-mode))))
     :config
     (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
     (push 'rotate-windows dired-sidebar-toggle-hidden-commands)

     (setq dired-sidebar-subtree-line-prefix "__")
     (setq dired-sidebar-theme 'vscode)
     (setq dired-sidebar-use-term-integration t)
     (setq dired-sidebar-use-custom-font t))
   #+end_src
** sudo-save
#+BEGIN_SRC emacs-lisp
(defun sudo-save ()
  "Save file with sudo"
  (interactive)
  (if (not buffer-file-name)
      (write-file (concat "/sudo:root@localhost:" (ido-read-file-name "File:")))
    (write-file (concat "/sudo:root@localhost:" buffer-file-name))))

#+END_SRC
** Multiple cursors
Some usage through chords (see chords)
#+begin_src emacs-lisp
(use-package multiple-cursors
  :config
  (setq mc/always-run-for-all t)
  :bind ("C-<" . mc/mark-next-like-this)
        ("C--" . mc/edit-lines))

#+end_src
** rename-file-and-buffer
#+begin_src emacs-lisp
(defun rename-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil))))))
#+end_src
** goto-last-change
#+begin_src emacs-lisp
(use-package goto-last-change
:bind ("C-Â§" . goto-last-change))
#+end_src
** smart-mode-line
#+begin_src emacs-lisp :tangle no
(use-package smart-mode-line
  :config (setq sml/theme 'respectful))
#+end_src
* Organizing and finding files and buffers
** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :init
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-idle-delay 0.2)
  (setq company-dabbrev-downcase nil))
(use-package request)
#+END_SRC


** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (setq-default helm-locate-project-list local-projects)
  (projectile-mode t))
#+END_SRC
** Treemacs
#+BEGIN_SRC emacs-lisp :tangle no
(use-package treemacs
  :config (treemacs-follow-mode 1)
  (treemacs-filewatch-mode 1)
  (treemacs-fringe-indicator-mode 1))
   (use-package treemacs-projectile
     :after treemacs projectile)
(defun my-treemacs-back-and-forth ()
  (interactive)
  (if (treemacs-is-treemacs-window-selected?)
      (aw-flip-window)
    (treemacs-select-window)))
#+END_SRC
** Springboard
#+BEGIN_SRC emacs-lisp
(use-package springboard)
#+END_SRC
** recentf: Keep opened files history
#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 100)
(setq recentf-max-saved-items 100)
(defun save-recentf-silently()
  (let ((inhibit-message t))
    (recentf-save-list)))
(run-at-time nil (* 5 60) 'save-recentf-silently)
#+END_SRC
** goto-last-change
#+BEGIN_SRC emacs-lisp
(use-package goto-last-change)
#+END_SRC

** Fuzzy find files (fzf). Bind it to helm-ff
#+BEGIN_SRC emacs-lisp
(use-package fzf
  :init
  (global-set-key (kbd "C-c g") (lambda () (interactive)
			    (fzf/start "~"))))

(defun my-helm-run-fzf (candidate &optional cmd-stream)
  (interactive)
  (let ((helm-current-dir (file-name-directory (helm-get-selection))))
      (fzf/start helm-current-dir cmd-stream)))

(defun my-helm-ff-switch-to-fzf ()
  "Stop helm find-files and use fzf"
  (interactive)
  (with-helm-alive-p
    (helm-exit-and-execute-action 'my-helm-run-fzf)))

(defun my-helm-ff-switch-to-fzf-dir ()
  "Stop helm find-files and use fzf (directories)"
  (interactive)
  (with-helm-alive-p
    (helm-get-default-action (lambda (x) (my-helm-run-fzf x "fdfind --type d")))))

#+END_SRC
* Org Mode


  
Unbind colliding mappings
#+begin_src emacs-lisp
(define-key org-mode-map (kbd "M-<down>") nil)
(define-key org-mode-map (kbd "M-<up>") nil)
(define-key org-mode-map (kbd "M-<left>") nil)
(define-key org-mode-map (kbd "M-<right>") nil)
(define-key org-mode-map (kbd "ESC <left>") 'org-metaleft)

(add-hook 'org-mode-hook 'auto-revert-mode)
#+end_src
** Org-appear
   
   Hide emphasis markers unless under cursor
   #+begin_src emacs-lisp
   (use-package org-appear
     :straight (:host github :repo "awth13/org-appear")
     :init
     (setq org-hide-emphasis-markers t)
     :config
     (add-hook 'org-mode-hook 'org-appear-mode))
   #+end_src
** Don't trail whitespace in org mode
#+begin_src emacs-lisp
 (add-hook 'org-mode-hook (lambda () (setq show-trailing-whitespace nil)))
#+end_src

** Clock

(Disabled)   
   
#+begin_src emacs-lisp :tangle no
 (unless (boundp 'org-clocking-buffer)
   (defalias 'org-clocking-buffer #'org-clock-is-active))

 (org-babel-do-load-languages
  'org-babel-load-languages
  '((python . t)))
#+end_src

** Journal, Rifle

 #+BEGIN_SRC emacs-lisp
 (require 'find-lisp)
 (setq calendar-week-start-day 1)
 (use-package org-journal
   :init
   (setq org-journal-dir "~/Org/Journal")
   (setq org-journal-file-type 'weekly)
   (setq org-journal-file-format "%Y-%m-%d.org")
   (setq org-journal-date-format "%y-%m-%d, %A"))
 #+END_SRC
 
** ox-gfm allows exporting Github Flavored markdown
 #+BEGIN_SRC emacs-lisp
 (use-package ox-gfm)
 #+END_SRC

** Generic Org settings 

All Org files are in /~Org/, add safeguards for disallowing editing folded trees,
refile tweaks. Auto-save all org buffers. 

Ignore some files, such as the capture template.

 #+BEGIN_SRC emacs-lisp
 (require 'find-lisp)
 (setq org-agenda-dim-blocked-tasks t)
 (setq org-enforce-todo-dependencies t)
 (setq org-agenda-directory "~/Org/")
 (setq org-directory "~/Org/")
 (setq org-agenda-files
       (remove (expand-file-name "~/Org/capture.org")
       (find-lisp-find-files org-agenda-directory "\.org$")))


 (setq-default org-catch-invisible-edits 'smart)
 (setq org-default-notes-file "~/Org/notes.org")
 (setq org-refile-targets '((org-agenda-files . (:maxlevel . 10))))

 (setq org-refile-use-outline-path 'file)
 (setq org-outline-path-complete-in-steps nil)
 (setq org-refile-allow-creating-parent-nodes 'confirm)

 (add-hook 'auto-save-hook 'org-save-all-org-buffers)
 (add-hook 'org-mode-hook 'flyspell-mode)

 (add-hook 'org-agenda-mode-hook (lambda () (setq show-trailing-whitespace nil)))

 (use-package org-super-agenda
   :config
   (setq org-super-agenda-groups
     '((:name "Overdue" :scheduled past)
       (:name "Today" 
           :time-grid t)
           (:auto-tags t)))
   (org-super-agenda-mode t))
 #+END_SRC

** Plantuml

#+BEGIN_SRC emacs-lisp
  (defun my-org-confirm-babel-evaluate (lang body)
    (not (string= lang "plantuml")))  ; don't ask for ditaa
  (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path
        (expand-file-name (concat dropbox-home "/home/elisp/java-libs/plantuml.jar")))

  (load (expand-file-name (concat dropbox-home "/home/elisp/ob-plantuml.el")))
#+END_SRC

** Org clock stuff
#+BEGIN_SRC emacs-lisp :tangle no
    (use-package org-clock-today)
    (use-package org-mru-clock)
  (defun x-org-clock-sum-today ()
    "Visit each file in `org-agenda-files' and return the total time of today's
  clocked tasks in minutes."
    (let ((files (org-agenda-files))
          (total 0))
      (org-agenda-prepare-buffers files)
      (dolist (file files)
        (with-current-buffer (find-buffer-visiting file)
          (setq total (+ total (org-clock-sum-today)))))
      total))
  (defun x-org-clock-get-clock-string-today ()
    "Form a clock-string, that will be shown in the mode line.
  If an effort estimate was defined for the current item, use
  01:30/01:50 format (clocked/estimated).
  If not, show simply the clocked time like 01:50. All Tasks"
    (let ((clocked-time (x-org-clock-sum-today)))
      (if org-clock-effort
          (let* ((effort-in-minutes (org-duration-to-minutes org-clock-effort))
                 (work-done-str
                  (propertize (org-duration-from-minutes clocked-time)
                              'face
                              (if (and org-clock-task-overrun
                                       (not org-clock-task-overrun-text))
                                  'org-mode-line-clock-overrun
                                'org-mode-line-clock)))
                 (effort-str (org-duration-from-minutes effort-in-minutes)))
            (format (propertize " [%s/%s] (%s)" 'face 'org-mode-line-clock)
                    work-done-str effort-str org-clock-heading))
        (format (propertize " [%s] (%s)" 'face 'org-mode-line-clock)
                (org-duration-from-minutes clocked-time)
                org-clock-heading))))
  (defun current-clock-time-to-file ()
     (interactive)
     (with-temp-file "~/.emacs.d/.task"
       (if (org-clocking-p)
         (insert (x-org-clock-get-clock-string-today))
         (insert ""))))
  (run-with-timer 1 60 'current-clock-time-to-file)
  (add-hook 'org-clock-in-hook 'current-clock-time-to-file)
  (add-hook 'org-clock-out-hook 'current-clock-time-to-file)


#+END_SRC
** org-clubhouse
#+BEGIN_SRC emacs-lisp
(use-package org-clubhouse
  :straight (:host github :repo "glittershark/org-clubhouse")
  :init (setq org-clubhouse-state-alist
      '(("TODO"   . "Backlog")
        ("ACTIVE" . "In Development")
        ("PENDING" . "Pending")
        ("REVIEW"   . "Ready for Review")
        ("DONE"   . "Completed")))
        (setq org-clubhouse-workflow-name "Development"))
#+END_SRC
** Emphasis ant other styles
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "â¤µ")
(setq org-emphasis-alist '(
			  ("/"  (:foreground "red" :background: "yellow"))
			  ("\""  (:foreground "red" :background: "yellow"))
			  ("/" italic "<i>" "</i>")
			  ("_" underline "<span style=\"text-decoration:underline;\">" "</span>")
			  ("-" (:overline t) "<span style=\"text-decoration:overline;\">" "</span>")
			  ("=" org-code "<code>" "</code>" verbatim)
			  ("*" org-verbatim "<code>" "</code>" verbatim)
			  ("+" (:strike-through t) "<del>" "</del>")))
(setq org-hide-emphasis-markers nil)
#+END_SRC
** Org-analyzer
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-analyzer)
#+END_SRC
** TODO Org attach screenshot

[[https://github.com/dfeich/org-screenshot][org-screenshot]] Do this to the end.

#+begin_src emacs-lisp
(use-package org-attach-screenshot
  :config 
  (define-key org-mode-map (kbd "C-c s") 'org-attach-screenshot)
  (setq org-attach-screenshot-dirfunction
	(lambda () "~/Org/Screenshots")		  
	org-attach-screenshot-command-line "spectacle -o %f -r -b -n"))
#+end_src

** Capture templates
#+BEGIN_SRC emacs-lisp
(use-package capture-org-template
  :straight (:host github :repo "ration/capture-org-template.el")

  :config 
  (setq org-capture-templates (capture-org-template "~/Org/capture.org")))

;; (setq org-capture-templates (append
;;                              (quote
;;                               (
;;                                ("P" "TODO Email" entry 
;;                                 (file+headline "~/Org/todo.org" "Inbox")
;;                                 "* TODO %:fromname: %a %?\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))")
;;                                ("b" "Bloggging" entry
;;                                 (file (lambda () "~/Org/blog.org"))
;;                                 "")
;;                                ("n" "Note" entry
;;                                 (file (lambda () "~/Org/notes.org"))
;;                                 "* %?")
;;                                ("t" "Generic TODO" entry
;;                                 (file+headline "~/Org/todo.org" "Inbox")
;;                                 "* TODO %?")
;;                                ("l" "Org Capture Text" entry (file+headline "~/Org/todo.org" "Protocol")
;;                                "* TODO %?\n%u\n#+begin_example\n%i\n#+end_example\n\nSource: %:link\n"
;;                                :empty-lines 1)
;;                                ("L" "Org Capture" entry (file+headline "~/Org/todo.org" "Protocol")
;;                                "* TODO %?\n%u\nSource: %:link\n"
;;                                :empty-lines 1)
;;                                )) (if (boundp 'project-specific-templates) project-specific-templates)))

#+END_SRC
** Reload images when running babel
#+BEGIN_SRC emacs-lisp
(defun shk-fix-inline-images ()
  (when org-inline-image-overlays)
    (org-redisplay-inline-images))

(with-eval-after-load 'org
  (add-hook 'org-babel-after-execute-hook 'shk-fix-inline-images))
#+END_SRC
** Bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
** org-gcal
If org-cal keys has been set install org-gcal and add a sync for it in agenda
#+begin_src emacs-lisp
(if (boundp 'org-gcal-client-id)
    (use-package org-gcal
      :config 
      (setq org-gcal-auto-archive t)
      (setq org-gcal-notify-p nil)
      (setq org-gcal-remove-api-cancelled-events t)
      (define-key org-agenda-mode-map (kbd "Ã¶") 'org-gcal-fetch)))
#+end_src
** Todoist
#+begin_src emacs-lisp
(if (boundp 'todoist-token)
    (use-package todoist
      :init (setq todoist-backing-buffer (concat org-agenda-directory "todoist.org"))))
#+end_src
* Hydra
#+begin_src emacs-lisp
(use-package hydra)
#+end_src
* Window management
Some window management and switching window is in global bindings. Maybe move here?
** Switch-window
Only need the resizing functions now
#+begin_src emacs-lisp
(use-package switch-window
  :bind ("C-s-<left>" . switch-window-mvborder-left)
  ("C-s-<right>" . switch-window-mvborder-right)
  ("C-s-<up>" . switch-window-mvborder-up)
  ("C-s-<down>" . switch-window-mvborder-down))
#+end_src
** Flashing active window when window is changed
#+begin_src emacs-lisp :tangle no
(make-face 'flash-active-buffer-face)
(set-face-attribute 'flash-active-buffer-face nil
                    :background "#FFFFFF" :foreground nil)
(defun highlight-selected-window ()
  "Highlight selected window with a different background color."
  (walk-windows (lambda (w)
                  (unless (eq w (selected-window))
                    (with-current-buffer (window-buffer w)
                      (buffer-face-set 'default)))))
  (buffer-face-set '(:background "#202020")))
(defun flash-active-buffer ()
  (interactive)
  (run-at-time "100 millisec" nil
               (lambda (remap-cookie)
                 (face-remap-remove-relative remap-cookie))
               (face-remap-add-relative 'default 'flash-active-buffer-face)))
(add-hook 'buffer-list-update-hook 'flash-active-buffer)
#+end_src
** Ace-windows
#+begin_src emacs-lisp
(use-package ace-window
:bind (("C-x Â§" . ace-window)))
#+end_src
** Shackle
#+BEGIN_SRC emacs-lisp
(use-package shackle
  :init
  (require 'shackle)
  (setq helm-display-function 'pop-to-buffer) ; make helm play nice
  (setq helm-swoop-split-window-function 'display-buffer)
  (add-to-list 'shackle-rules
               '("\\`\\*helm.*?\\*\\'" :regexp t :align t :size 0.9))
  (add-to-list 'shackle-rules
               '("\\`\\*Helm.*?\\*\\'" :regexp t :align right :size 0.4))
  (add-to-list 'shackle-rules
               '("\\`\\*Helpful.*?\\*\\'" :regexp t :align right :size 0.4))

  (add-to-list 'shackle-rules
               '("\\`\\*PLANTUML.*?\\*\\'" :popup t :regexp t :align below :size 0.4))

  :config
  (shackle-mode t))
#+END_SRC
** Purpose
TODO setup purpose
#+begin_src emacs-lisp :tangle no
(use-package window-purpose
  :init
  (require 'window-purpose)
;;  (add-to-list)
  (purpose-mode t))
#+end_src
* File editing modes
  *
#+BEGIN_SRC emacs-lisp

(if (version<= emacs-version "26")
    (use-package cl))

  (use-package pcre2el)

  (use-package xml+)
  (use-package restclient)
  (use-package powershell)
  (use-package plantuml-mode
    :init
    (setq plantuml-jar-path (concat dropbox-home "/home/elisp/java-libs/plantuml.jar"))
    (setq plantuml-default-exec-mode 'jar))

  (use-package dockerfile-mode)
  (use-package graphql)
  (use-package graphql-mode)

  (use-package yaml-mode
    :bind ("C-<tab>" . outline-cycle)
    :hook (yaml-mode . outline-minor-mode)
          (yaml-mode . (lambda ()  (progn (setq outline-regexp "^ *##")))))


  (use-package live-py-mode
    :config
    (setq live-py-version "python3"))
  (use-package highlight-indent-guides
    :config
    (setq highlight-indent-guides-method 'character)
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
#+END_SRC
** json

If you regularly use JSON string payloads embedded in another payload, you can use this to extract the contents as prettified json.

#+begin_src emacs-lisp
(defun my-json-pretty-print-from-string-to-kill-ring (start end)
  "Copy contents of a embedded json object and copy the content pretty printed into kill ring"
  (interactive "r")
  (if (use-region-p)
      (let ((regionp (buffer-substring start end)))
        (with-temp-buffer
          (insert (json-read-from-string regionp))
          (json-pretty-print-buffer)
          (clipboard-kill-region (point-min) (point-max))))))
(use-package json-mode)
#+end_src
** Markdown
#+BEGIN_SRC emacs-lisp
(add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC
** DONE Type/Javascript
#+BEGIN_SRC emacs-lisp

(defun my-lsp-mode-before-save-hook ()
  (when (and lsp-mode (eq major-mode 'typescript-mode))
    (lsp-eslint-apply-all-fixes)))

(use-package js2-mode
  :mode "\\.js\\'"
  :init
  (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
  (add-hook 'js2-mode-hook #'flymake-eslint-enable)
  (add-hook 'before-save-hook #'my-lsp-mode-before-save-hook)

  (setq js2-strict-missing-semi-warning nil)
  (setf js2-mode-indent-inhibit-undo t)
  (setq-default indent-tabs-mode nil)

  :config
  (setq lsp-eslint-server-command
        '("node"
          "/home/lahtela/Software/eslint/extension/server/out/eslintServer.js"
          "--stdio"))
  (setq lsp-eslint-node-path "/home/lahtela/Software/node/")
  (setq lsp-eslint-auto-fix-on-save t)
  (setq lsp-eslint-validate '("javascript" "javascriptreact" "typescript"))
  (setq lsp-eslint-trace-server nil)


  (with-eval-after-load "lsp-javascript-typescript"
    (add-hook 'js2-mode-hook #'lsp))
  (setq js2-basic-offset 2))

(use-package web-mode
  :ensure t
  :mode (("\\.html?\\'" . web-mode)
         ("\\.tsx\\'" . web-mode)
         ("\\.jsx\\'" . web-mode))
  :config
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-block-padding 2
        web-mode-comment-style 2

        web-mode-enable-css-colorization t
        web-mode-enable-auto-pairing t
        web-mode-enable-comment-keywords t
        web-mode-enable-current-element-highlight t
        web-mode-enable-auto-indentation nil))

(defun ts-goto-test-or-source ()
  "Switch between test and implementation"
  (interactive)
  (let* ((file (buffer-file-name))
         (test (string-match "\\(.*?\\)\\(\.test\\)?\\(\.tsx?\\)$" file)))

    (if (match-string 2 file)
        (let ((source (replace-regexp-in-string "\.test" "" file)))
          (if (file-exists-p source) (find-file source)))
      (let ((test (concat (match-string 1 file) ".test" (match-string 3 file))))
        (if (file-exists-p test) (find-file test))))))



(use-package typescript-mode
  :ensure t
  :bind (("M-<return>" . ts-goto-test-or-source))
  :config
  (setq typescript-indent-level 2)
  (add-hook 'typescript-mode #'subword-mode))

;(use-package tide
;  :init
;  :ensure t
;  :after (typescript-mode company flycheck)
;  :hook ((typescript-mode . tide-setup)
;         (typescript-mode . tide-hl-identifier-mode)))

(use-package css-mode
  :config
  (setq css-indent-offset 2))

(use-package jest
  :init (setq jest-executable "~/Software/nodejs/bin/npm test --"))
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck)
;  :hook (yaml-mode . flycheck-mode))


#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :config
  (define-key elpy-mode-map (kbd "M-<down>") nil)
  (define-key elpy-mode-map (kbd "M-<up>") nil)
  (define-key elpy-mode-map (kbd "M-<left>") nil)
  (define-key elpy-mode-map (kbd "M-<right>") nil)
  (setq elpy-rpc-pythonpath "/home/lahtela/.emacs.d/straight/repos/elpy")
:init (elpy-enable))
#+END_SRC
** logview
#+begin_src emacs-lisp
(use-package logview
    :mode (("\\.log?\\'" . logview-mode))
:hook ((logview-mode . read-only-mode)
       (logview-mode . auto-revert-mode)
       (logview-mode . (lambda () (setq show-trailing-whitespace nil)))))
#+end_src
** LSP

LSP is set up, but does not trigger automatically from builds

#+BEGIN_SRC emacs-lisp

;;(use-package lsp)
;;  :ensure lsp-mode
;;  :config
;;  (require 'lsp-clients)

;;  (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
;;  :init
;;  (setf lsp-eldoc-render-all nil)
;;  (setq lsp-inhibit-message t)
;;  (setq lsp-message-project-root-warning t))

(use-package lsp-mode
  :config (setq lsp-clients-typescript-log-verbosity "debug")
  (setq gc-cons-threshold 100000000)
  (setq lsp-file-watch-threshold 30000)
  (setq lsp-log-io 1))

(use-package lsp-ui :commands lsp-ui-mode)
(use-package helm-lsp :commands helm-lsp-workspace-symbol)
;(use-package lsp-treemacs
;  :config (lsp-treemacs-sync-mode 1)
;  :commands lsp-treemacs-errors-list)

(use-package lsp-java)

(use-package ccls
  :hook ((c-mode c++-mode objc-mode cuda-mode) .
         (lambda () (require 'ccls) (lsp))))

;;(use-package company-lsp
;;  :config
;;  (push 'company-lsp company-backends)
;;  (add-hook 'js2-mode-hook #'lsp))


#+END_SRC
** DAP
#+begin_src emacs-lisp :tangle no
(use-package dap-mode)
#+end_src
** Kotlin
#+begin_src emacs-lisp :tangle no
(use-package kotlin-mode)
#+end_src
** CSharp
#+begin_src emacs-lisp :tangle no
(use-package csharp-mode)
#+end_src
** Clojure
#+begin_src emacs-lisp
(use-package clojure-mode)
(use-package cider)
#+end_src
* Compilation modifications
Change compilation directory
#+begin_src emacs-lisp
(defun compile-in-dir (dir command)
  (interactive "DCompile in directory: \nsCommand: ")
  (let ((default-directory dir))
    (compile command)))
#+end_src
* Programming helpers
* Lastpass
#+begin_example emacs-lisp
(use-package lastpass
 :config
 (setq lastpass-user "lahtela@iki.fi")
 (setq lastpass-trust-login t)
 (lastpass-auth-source-enable))
#+end_example
* Elfeed (RSS reader)
#+begin_src emacs-lisp
(defun my-elfeed-tag-sort (a b)
;  (message (format "%s" a))
  (let* ((a-tags (format "%s" (elfeed-entry-tags a)))
         (b-tags (format "%s" (elfeed-entry-tags b))))
    (if (string= a-tags b-tags)
        (< (elfeed-entry-date b) (elfeed-entry-date a)))
    (string< a-tags b-tags)))

(use-package elfeed
  :config
    (setq shr-width 80) ;; Read view narrowing
    (setf elfeed-search-sort-function #'my-elfeed-tag-sort))
(use-package elfeed-goodies
:config (elfeed-goodies/setup))

;; (setq elfeed-log-level 'debug)
(use-package elfeed-protocol
  :straight (elfeed-protocol
             :local-repo "~/git/own/github/elfeed-protocol"
             :type git)
  :config
  (setq elfeed-use-curl t)
  (setq elfeed-protocol-ttrss-maxsize 2000) ;; bigger than 200 is invalid (unless you hack it ;)
  (setq elfeed-feeds
      '(
        ("ttrss+https://admin@lahtela.me/tt"
         :use-authinfo t
        )))
  (elfeed-protocol-enable))
;;(use-package elfeed-org
;;  :config
;;  (setq rmh-elfeed-org-files (list (concat dropbox-home "Org/elfeed.org")))
;;  (elfeed-org))
(use-package elfeed-dashboard
  :config
  (global-set-key (kbd "C-c e") 'elfeed-dashboard)
  (setq elfeed-dashboard-file "~/Org/elfeed-dashboard.org")
  ;; update feed counts on elfeed-quit
  (advice-add 'elfeed-search-quit-window :after #'elfeed-dashboard-update-links))
#+end_src
Display dates on the feeds
#+begin_src emacs-lisp
(defun elfeed-goodies/search-header-draw ()
  "Returns the string to be used as the Elfeed header."
  (if (zerop (elfeed-db-last-update))
      (elfeed-search--intro-header)
    (let* ((separator-left (intern (format "powerline-%s-%s"
                                           elfeed-goodies/powerline-default-separator
                                           (car powerline-default-separator-dir))))
           (separator-right (intern (format "powerline-%s-%s"
                                            elfeed-goodies/powerline-default-separator
                                            (cdr powerline-default-separator-dir))))
           (db-time (seconds-to-time (elfeed-db-last-update)))
           (stats (-elfeed/feed-stats))
           (search-filter (cond
                           (elfeed-search-filter-active
                            "")
                           (elfeed-search-filter
                            elfeed-search-filter)
                           (""))))
      (if (>= (window-width) (* (frame-width) elfeed-goodies/wide-threshold))
          (search-header/draw-wide separator-left separator-right search-filter stats db-time)
        (search-header/draw-tight separator-left separator-right search-filter stats db-time)))))

(defun elfeed-goodies/entry-line-draw (entry)
  "Print ENTRY to the buffer."

  (let* ((title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
         (date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
         (feed (elfeed-entry-feed entry))
         (feed-title
          (when feed
            (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
         (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
         (tags-str (concat "[" (mapconcat 'identity tags ",") "]"))
         (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                         elfeed-goodies/tag-column-width 4))
         (title-column (elfeed-format-column
                        title (elfeed-clamp
                               elfeed-search-title-min-width
                               title-width
                               title-width)
                        :left))
         (tag-column (elfeed-format-column
                      tags-str (elfeed-clamp (length tags-str)
                                             elfeed-goodies/tag-column-width
                                             elfeed-goodies/tag-column-width)
                      :left))
         (feed-column (elfeed-format-column
                       feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                elfeed-goodies/feed-source-column-width
                                                elfeed-goodies/feed-source-column-width)
                       :left)))

    (if (>= (window-width) (* (frame-width) elfeed-goodies/wide-threshold))
        (progn
          (insert (propertize date 'face 'elfeed-search-date-face) " ")
          (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
          (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
          (insert (propertize title 'face title-faces 'kbd-help title)))
      (insert (propertize title 'face title-faces 'kbd-help title)))))

#+end_src

Automatic filtering of some entries
#+begin_src emacs-lisp

(setq my-elfeed-filter-list '("Apple" "Some Covid Links" ))


(defun my-emacs-filter (entry)
  (when (cl-some (lambda (pred) (string-match pred (elfeed-entry-title entry))) my-elfeed-filter-list)
    (elfeed-untag entry 'unread)))

(defun my-elfeed-filter-uninteresting ()
  (interactive)
  (mapcar 'my-emacs-filter elfeed-search-entries)
  (elfeed-search-update :force))


(add-hook 'elfeed-new-entry-hook #'my-emacs-filter)
#+end_src

Filter feed to current topic

#+begin_src emacs-lisp
(defun my-elfeed-filter-current-feed ()
  (interactive)
  (let* ((entry (elfeed-search-selected :single))
         (feed (elfeed-entry-feed entry))
         (feed-url (elfeed-protocol-subfeed-url (elfeed-feed-url feed))))
    (with-current-buffer (elfeed-search-buffer)
      (setf elfeed-search-filter (format "%s =%s" elfeed-search-filter feed-url))
    (elfeed-search-update :force))))
(define-key elfeed-search-mode-map "f" 'my-elfeed-filter-current-feed)
#+end_src

* UUID
#+begin_src emacs-lisp
(use-package uuid)
#+end_src

* Completion frameworks, Helm, Swoop and related
#+BEGIN_SRC emacs-lisp 
(defun helm-execute-if-single-persistent-action (&optional attr split-onewindow)
  "Execute persistent action if the candidate list is less than 2 OR if theres no input and only one non trivial thing to select from"
  (interactive)
  (with-helm-alive-p
    (cond ((and (string= helm-input helm-ff-default-directory) (eq (helm-get-candidate-number) 3))
           (progn
             (helm-next-line)
             (helm-next-line)
             (helm-execute-persistent-action))
           )
          ((> (helm-get-candidate-number) 2) (double-flash-mode-line))
          (t (helm-execute-persistent-action))
          )))

(use-package helm
  :config
  (require 'helm-files)
  (setq helm-ff-allow-non-existing-file-at-point t)
  (unless (boundp 'helm-source-find-files)
    (setq helm-source-find-files (helm-make-source
                                     "Find Files" 'helm-source-ffiles)))
  (add-hook
   'helm-find-files-after-init-hook
   (lambda () (helm-add-action-to-source "C-, Switch to fzf" #'my-helm-run-fzf helm-source-find-files)))
  :bind (("M-x" . helm-M-x)
         ("C-x b" . helm-buffers-list)
         ("C-c f" . helm-recentf)
         ("M-y" . helm-show-kill-ring)

         ("C-x C-f" . helm-find-files)
         :map helm-find-files-map
         ("C-," . my-helm-ff-switch-to-fzf)
         ("C-." . my-helm-ff-switch-to-fzf-dir)
         ("<C-backspace>" . helm-find-files-up-one-level)
         :map helm-read-file-map
         ("<C-backspace>" . helm-find-files-up-one-level)

         :map helm-map
         ([tab] . helm-execute-if-single-persistent-action)
         ("C-i" . helm-select-action)))

(use-package helm-ag
  :init (custom-set-variables
         '(helm-follow-mode-persistent t)))
(defun my-helm-swoop-pre-input-function () "")
(use-package helm-swoop
  :bind (("C-s" . helm-swoop))
  :config
  (setq helm-swoop-speed-or-color nil)
  (setq helm-swoop-pre-input-function 'my-helm-swoop-pre-input-function)
  (bind-keys :map helm-swoop-map
             ("C-s" . kill-whole-line)))
(use-package helm-org-rifle)
(helm-mode 1)
(global-set-key (kbd "M-s M-s") 'isearch-forward)
(use-package helm-projectile)
(use-package helm-org
  :init
  (add-to-list 'helm-completing-read-handlers-alist '(org-set-tags-command . helm-org-completing-read-tags)))
#+END_SRC
* (Ma) Git
Add diffall to command list
#+BEGIN_SRC emacs-lisp

(transient-define-suffix magit-diffall (args)
  "Invoke diffall against branch or commit.
"
  (interactive (list (magit-read-other-branch-or-commit "Diff" t "origin/master"))
  (run-hooks 'magit-credential-hook)
  (magit-run-git-async "diffall" args)))


(use-package magit
  :config
  (transient-bind-q-to-quit)
  (transient-insert-suffix 'magit-diff "d" '("a" "Diffall" magit-diffall)))

(use-package magit-delta
  :hook (magit-mode . magit-delta-mode))


(use-package forge)
#+END_SRC
** ediff
#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(custom-set-variables
 '(ediff-window-setup-function 'ediff-setup-windows-plain)
 '(ediff-diff-options "-w")
 '(ediff-split-window-function 'split-window-horizontally))
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)

#+end_src
* Blogging
#+BEGIN_SRC emacs-lisp
(use-package easy-jekyll
  :config
  (setq easy-jekyll-basedir (concat dropbox-home "git/blog/"))
  (setq easy-jekyll-url "https://lahtela.me")
  (setq markdown-command "pandoc -f markdown -t html -s --mathjax --highlight-style=pygments"))
#+END_SRC
* Save bookmarks always
If you set the variable bookmark-save-flag to 1, each command that sets a bookmark will also save your bookmarks; this
way, you donât lose any bookmark values even if Emacs crashes. The value, if a number, says how many bookmark
modifications should go by between saving. If you set this variable to nil, Emacs only saves bookmarks if you explicitly
use M-x bookmark-save.
#+begin_src emacs-list
(setq bookmark-save-flag 1)
(require 'bookmark)
(bookmark-bmenu-list)

#+end_src
* Dashboard
#+BEGIN_SRC emacs-lisp

(defun dashboard-insert-mu4e (list-size)
  (dashboard-insert-section
   "Mu4e"
   (dashboard-subseq '("Dashboard" "Work INBOX") 0 list-size)
   list-size
   "e"
   `(lambda (&rest ignore) (pcase ,el
                             ("Dashboard" (mu4e))
                             ("Work INBOX" (mu4e-headers-search "maildir:\"/Work/INBOX\""))))
   (format "%s" el)))


(defun dashboard-insert-elfeed (list-size)
  (dashboard-insert-section
   (format "Elfeed (%s unread)" (elfeed-dashboard-query-count "+unread"))
   (dashboard-subseq '("Dashboard" "Unread") 0 list-size)
   list-size
   "u"
;;   `(lambda (&rest ignore) (let() (elfeed-update) (elfeed-dashboard)))
   `(lambda (&rest ignore) (pcase ,el
                             ("Dashboard" (let() (elfeed-update) (elfeed-dashboard)))
                             ("Unread" (elfeed))))
    (format "%s" el)))

(use-package dashboard
  :demand t
  :init
  ;; Some org versions had this bug
  (setq org-priority-highest org-highest-priority)
  (setq org-priority-lowest org-lowest-priority)


  :config
  (require 'dashboard)
  (add-to-list 'dashboard-item-generators  '(elfeed . dashboard-insert-elfeed))
  (add-to-list 'dashboard-item-generators  '(mu4e . dashboard-insert-mu4e))
  (setq dashboard-items '(;;(recents  . 5)
                        (bookmarks . 5)
                        ;; (projects . 5)
                        (agenda . 5)
                        (mu4e . 5)
                        (elfeed . 5)))

  (dashboard-setup-startup-hook))

#+END_SRC
* Sync agendas

Synchronize Calendar on boot
#+begin_src emacs-lisp
(defun my-sync-orgs ()
  "Synchronize ORG stuff periodically"
  (interactive)
  (if my-sync-gcal
      (progn (message "Synchronizing calendar")
             (org-gcal-sync t t))))

(add-hook 'after-init-hook 'my-sync-orgs)
(run-with-timer 0 (* 30 60) 'my-sync-orgs)
#+end_src

* Browser / EAF
Default browser per domains
#+begin_src emacs-lisp
(setq
 browse-url-browser-function
 '(
  ("drive\\.google" . browse-url-chrome)
  ("." . browse-url-default-browser)
  ))
#+end_src

#+begin_src emacs-lisp
(use-package epc)
(straight-use-package '(eaf :type git
                            :host github
                            :repo "manateelazycat/emacs-application-framework"
                            :files ("*.el" "*.py" "core" "app")))
#+end_src
* Terminal (vterm)
- Synchronize default-directory with the added vterm-eval-cmds
- When scrolling up the buffer with ctrl-up, enable vterm-copy-mode
- Add a binding to find-trace-paths to ctrl-. into path texts in traces

#+begin_src emacs-lisp
(use-package find-trace-paths
  :straight (:host github :repo "ration/find-trace-paths"))

(defun my-vterm-backward-paragraph (&optional arg)
    (interactive)
  (unless vterm-copy-mode (vterm-copy-mode t))
  (backward-paragraph arg))

(defun vterm-update-pwd (path)
  (setq default-directory path))
  (add-to-list 'shackle-rules
               '("\\`\\*helm.*?\\*\\'" :regexp t :align t :size 0.9))

(defun my-clone-buffer () 
  "Clone current buffer"
  (interactive)
  (let ((current-buffer (format "%s *copy*" (buffer-name))))
        (get-buffer-create current-buffer)
        (copy-to-buffer current-buffer (point-min) (point-max))))


(if module-file-suffix
      (use-package vterm
        :bind (:map vterm-mode-map
                    (( "C-." . find-trace-paths)
                     ( "C-<up>" . my-vterm-backward-paragraph)))
        :custom (vterm-kill-buffer-on-exit t)
        :init
        (global-set-key (kbd "C-c t") 'vterm)
        (setq vterm-max-scrollback 10000)
        (require 'vterm)
        (add-to-list 'vterm-eval-cmds '("update-pwd" (lambda (path) (setq default-directory path))))
        :hook ((vterm-mode . (lambda () (setq show-trailing-whitespace nil))))))
#+end_src
* Windows OS
#+BEGIN_SRC emacs-lisp
  ;; Load the ssh agent into environment variables if we have the pid file
  (defun load-agent-socket-env()
    (interactive)
    (defvar pid_file (concat (getenv "TEMP") "\\" "ssh_agent.pid"))
    (if (file-exists-p pid_file)
        (progn
        (setenv "SSH_AUTH_SOCK" (save-excursion
                                  (with-temp-buffer
                                    (insert-file-contents pid_file)
                                    (goto-char 1)
                                    (re-search-forward "SSH_AUTH_SOCK=\\(.*?\\);")
                                    (match-string 1)
                                    )))
      (setenv "SSH_AGENT_PID" (save-excursion
                                (with-temp-buffer
                                  (insert-file-contents pid_file)
                                  (goto-char 1)
                                  (re-search-forward "SSH_AGENT_PID=\\(.*?\\);")
                                  (match-string 1)
                                  ))))))





  (if (string-equal system-type "windows-nt")
      (progn
        (use-package ssh-agency)
        (setq find-program (concat git-home "/usr/bin/find.exe"))
        (setq grep-program (concat git-home "/bin/grep.exe"))
        (setq ispell-program-name "C:/Tatu/Apps/hunspell/bin/hunspell.exe")
        (setq helm-ag-base-command "c:/tatu/bin/ag --vimgrep")
  ))

#+END_SRC
* Global Bindings
Various global bindings
#+BEGIN_SRC emacs-lisp

(defun kill-and-save ()
  (interactive)
  (progn (save-buffer (current-buffer)) (kill-current-buffer)))

(global-set-key (kbd "ESC s-<f1>")  'kill-current-buffer)
(global-set-key (kbd "ESC <f1>")  'kill-and-save)
(global-set-key [f1]  'goto-line)
(global-set-key [f2]  'helm-projects-find-files)
(global-set-key [f3]  'helm-recentf)
(global-set-key [f4]  'helm-ag)

(global-set-key [f5]  'compile)
(global-set-key [f6]  'next-error)
(global-set-key [f8]  'magit-status)

(global-set-key [f9]  'org-agenda-list)
(global-set-key [f10]  'helm-org-rifle)
(global-set-key [f11]  (lambda () (interactive) (switch-to-buffer "*dashboard*")))
(global-set-key [f12]  'org-capture)

(global-set-key (kbd "M-k") 'kill-line-without-copy)

(global-set-key (kbd "C-Â§") 'whitespace-mode)
(global-set-key (kbd "s-Â§") (lambda () (interactive) (find-file current-notes-file)))
(global-set-key (kbd "M-<up>") 'windmove-up)
(global-set-key (kbd "M-<down>") 'windmove-down)
(global-set-key (kbd "M-<left>") 'windmove-left)
(global-set-key (kbd "M-<right>") 'windmove-right)

(global-set-key (kbd "M-<backspace>") 'backward-kill-word-without-copy)
(global-set-key (kbd "M-z") 'zap-up-to-char)
(global-set-key (kbd "<M-S-up>") 'scroll-down-line)
(global-set-key (kbd "<M-S-down>") 'scroll-up-line)

(global-set-key (kbd "M-C-(") (lambda () (interactive) (scroll-down 10)))
(global-set-key (kbd "M-C-)") (lambda () (interactive) (scroll-up 10)))
(global-set-key (kbd "C-c o") 'helm-find-files)
(global-set-key (kbd "C-z") 'undo)
(global-set-key (kbd "C-Ã¶") (lambda () (interactive) (point-to-register ?m)))
(global-set-key (kbd "C-Ã¤") (lambda () (interactive) (jump-to-register ?m)))

#+END_SRC
** Key chords
#+begin_src emacs-lisp
(use-package key-chord
  :config
  (key-chord-define-global ",," 'avy-goto-char-timer)
  (key-chord-define-global "xx" 'helm-M-x)
  (key-chord-define-global "vv" 'goto-line)
  (key-chord-define-global "bb" 'purpose-switch-buffer-overload)
  (key-chord-mode 1))
#+end_src
* Databases
* AWS SAW

Read AWS logs from emacs.

#+begin_src emacs-lisp :tangle no
(use-package aws-saw
  :straight (:host github :repo "ration/aws-saw.el"))
#+end_src

* Task organizer
My own task organizer stuff
#+begin_src emacs-lisp
(use-package chore
  :straight (:host github :repo "ration/chore.el")
  :config (key-chord-define-global "Â§Â§" 'chore-switch-to-note))
#+end_src
* email
#+begin_src emacs-lisp
(require 'mu4e)
;; use mu4e for e-mail in emacs
(setq mail-user-agent 'mu4e-user-agent)
(setq mu4e-mu-binary "/usr/local/bin/mu")
(setq mu4e-confirm-quit nil)
(setq mu4e-html2text-command "html2text -utf8 -width 72")
(setq mu4e-view-prefer-html t)
(define-key mu4e-headers-mode-map (kbd "x") (lambda() (interactive) (mu4e-mark-execute-all t)))

;; Update email index every 5 minutes
(run-with-timer 0 (* 5 60) 'mu4e-update-index)

(setq   mu4e-maildir-shortcuts
    '( (:maildir "/Work/INBOX"   :key ?i)))


  ;; set headers
  (setq mu4e-headers-fields
        '( (:date          .  25)    ;; alternatively, use :human-date
           (:flags         .   6)
           (:from          .  22)
           (:thread-subject .  nil))) ;; alternatively, use :thread-subject

 (setq mu4e-contexts
    `( ,(make-mu4e-context
	  :name "Iki"
	  :enter-func (lambda () (mu4e-message "Entering Iki context"))
          :leave-func (lambda () (mu4e-message "Leaving Iki context"))
	  ;; we match based on the contact-fields of the message
	  :match-func (lambda (msg)
			(when msg
			  (string-match-p "^/iki" (mu4e-message-field msg :maildir))))
	  :vars '( ( user-mail-address	    . "lahtela@iki.fi"  )
                   ( mu4e-refile-folder . "/iki/Archive")
		   ( user-full-name	    . "Tatu Lahtela" )))
       ,(make-mu4e-context
	  :name "Work"
	  :enter-func (lambda () (mu4e-message "Switch to the Work context"))
	  ;; no leave-func
	  ;; we match based on the maildir of the message
	  ;; this matches maildir /Work and its sub-directories
	  :match-func (lambda (msg)
			(when msg
			  (string-match-p "^/Work" (mu4e-message-field msg :maildir))))
	  :vars `( ( user-mail-address	     . ,my-work-email-address )
		   ( user-full-name	     . "Tatu Lahtela" )
                   ( mu4e-refile-folder . "/Work/Archive")
		   ( mu4e-compose-signature  . ,my-work-email-signature)))))
  ;; set mail folders
  (setq  mu4e-maildir       "~/Mail/"   ;; top-level Maildir
;;         mu4e-sent-folder   "/Sent"       ;; folder for sent messages
;;         mu4e-refile-folder "/Archive"
;;         mu4e-drafts-folder "/Drafts"     ;; unfinished messages
;;         mu4e-trash-folder  "/Trash"      ;; trashed messages
;;         user-mail-address "lahtela@iki.fi"
         )

(add-to-list 'mu4e-bookmarks
  '(:name "IKI Inbox"
      :query "maildir:/iki/INBOX"
      :key ?i))

(setq mu4e-get-mail-command "true") ;; "offlineimap" <- in cronb

(require 'smtpmail)
(setq message-send-mail-function 'smtpmail-send-it
   starttls-use-gnutls t
   smtpmail-auth-credentials "~/.authinfo.gpg"
   smtpmail-default-smtp-server "mail.kapsi.fi"
   smtpmail-smtp-user "talahtel"
   smtpmail-smtp-server "mail.kapsi.fi"
   smtpmail-smtp-service 587)
(global-set-key (kbd "C-c m") 'mu4e)
#+end_src
Alert from emails [[https://github.com/iqbalansari/mu4e-alert]]
#+begin_src emacs-lisp
(use-package mu4e-alert
:config
(setq mu4e-alert-interesting-mail-query
      (concat
       "flag:unread"
       " AND NOT flag:trashed"
       " AND (maildir:/Work/INBOX OR maildir:/iki/INBOX)"))
(add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
)
#+end_src
* Spell checking wcheck-mode

If someone knows exactly how this works, I'd like to know!
But something like this is needed:
#+begin_src bash :tangle no
apt-get install enchant-2 libenchant-voikko tmispell-voikko
#+end_src

This also relies on a script that allows feeding multiple dictionaries:
#+begin_src bash :tangle no
#!/bin/bash
while read line
do
    MODE="-a"
    if [ $1 == "-l" ]; then
        MODE="-l"
    fi
    echo "$line" | enchant-2 $MODE -d en_US | enchant-2 $MODE -d fi_FI
done < "${2:-/dev/stdin}"
#+end_src

#+begin_src emacs-lisp
(defun enchant-suggestions-menu (marked-text)
  (cons (cons "[Add to dictionary]" 'enchant-add-to-dictionary)
        (wcheck-parser-ispell-suggestions)))

(defvar enchant-dictionaries-dir "~/.config/enchant")

(defun enchant-add-to-dictionary (marked-text)
  (let* ((word (aref marked-text 0))
         (language (aref marked-text 4))
         (file (let ((code (nth 1 (member "-d" (wcheck-query-language-data
                                                language 'action-args)))))
                 (when (stringp code)
                   (concat (file-name-as-directory enchant-dictionaries-dir)
                           code ".dic")))))

    (when (and file (file-writable-p file))
      (with-temp-buffer
        (insert word) (newline)
        (append-to-file (point-min) (point-max) file)
        (message "Added word \"%s\" to the %s dictionary"
                 word language)))))

(use-package wcheck-mode
  :commands (wcheck-mode)
  :init
  (custom-set-faces
    '(wcheck-default-face ((t (:underline (:color: "red" :style wave)))))
    )

  (setq wcheck-language-data
    '
    (
      ("English"
        (program . "/usr/bin/enchant-2")
        (args "-l" "-d" "en_US")
        (action-program . "/usr/bin/enchant-2")
        (action-args "-a" "-d" "en_US")
        (action-parser . enchant-suggestions-menu)
;;        (read-or-skip-faces
;;          ;; Only check comments & strings.
;;          ((emacs-lisp-mode c-mode)
;;            read font-lock-comment-face
;;            read font-lock-string-face
;;            )
;;          (nil))
;;
        )
      ("Finnish"
        (program . "/usr/bin/enchant-2")
        (args "-l" "-d" "fi_FI")
        (action-program . "/usr/bin/enchant-2")
        (action-args "-a" "-d" "fi_FI")
        (action-parser . enchant-suggestions-menu)
      )
      ("Finglish"
        (program . "/home/lahtela/bin/finglish")
        (args "-l" )
        (action-program . "/home/lahtela/bin/finglish")
        (action-args "-a")
        (action-parser . enchant-suggestions-menu)
      )
    ))
  (setq wcheck-language "Finglish")
  )
#+end_src
* Spotify

Use smudge. Assumes keys defined in local.el
#+begin_example
(setq smudge-oauth2-client-secret nil)
(setq smudge-oauth2-client-id nil)
#+end_example

#+begin_src emacs-lisp
(use-package smudge
  :straight (:host github :repo "danielfm/smudge"))


#+end_src
* Exit Hook

Just save everything if we get TERM

#+begin_src emacs-lisp
(setq confirm-kill-processes nil)
(defun save-all () (interactive) (save-some-buffers t))
(add-hook 'kill-emacs-hook 'save-all)
#+end_src
